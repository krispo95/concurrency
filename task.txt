Есть список воркеров, каждый из которых горутина, читающая канал с задачами.

Есть основной поток, ставящий задачи.

Задачи отдаются в виде дерева, то есть

{{
  "task": [1,3,6,8],
  "child" : [
    {
      "task" : [4,11,22],
      "child" : [
        {
          "task" : [112,33,44]
        }
      ]
    },
    {
      "task" : [54,14,22],
      "child" : [
        {
          "task" : [112,33,414]
        },
        {
          "task" : [112,33,452]
        }
      ]
    }
  ]
}

Каждая дочерняя задача опирается на результаты вычислений предыдущей задачи.
В нашем случае, пусть будет сумма чисел.

По сути получается дерево задач, каждую ветвь которой можно обойти конкуретно

Дерево может быть любой воженности

число дочерних задач не ограничено

Задача обработать дерево конкуретно и слать в основной ожидающий поток исполнения результаты.
Ожидающий поток, запустивший дерево задач должен получить все результаты

То есть как только последний узел будет обработан, только тогда ожидающий поток сможет идти дальше, поскольку он получит все результаты

Стоит учитывать, что дерево может быть неравномерным, вложенности ветвей разные


----------------------------
воркер
----------------------------

type worker struct {
  *application.Context

  tasks <-chan *task
  stop  <-chan struct{}
  pool  *workerPool
}

func (w *worker) run() {
  for {
    select {
    case <-w.stop:
      return
    case task := <-w.tasks:
      w.runRpc(task)
    }
  }
}
-----------------------------
инициализация группы воркеров
-----------------------------

for i := uint(0); i < count; i++ {
      w := &worker{
        Context: appCtx,
        tasks:   pool.tasks,
        stop:    pool.stop,
        pool:    pool,
      }
      go w.run()
    }
-----------------------------